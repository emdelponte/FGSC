---
title: "SAD data author analysis"
output:
  html_document:
    depth: 5
    number_sections: no
    theme: default
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: yes
  html_notebook: default
date: 'Created: 2016-10-01 <br/>Last update: `r Sys.Date()`'
---



# Read data

```{r, message=FALSE, warning=FALSE}

# read an xml file 
# Note: the "<author>"" field was sub "<author>;" using a text editor
library(tidyverse) # several useful packages
library(XML)
sad_xml<-xmlParse("conferido.xml")
sad <- xmlToDataFrame(nodes = getNodeSet(sad_xml, "//record"))
```


# Select variables

```{r}
vars <- c("contributors", "titles", "volume", "issue", "pages", "dates" )
sad1 <- sad %>% 
 select(one_of(vars))
sad1$contributors <- gsub(",", "", sad1$contributors)
```



# Aauthorship

All authors of an article are within a same variable. Let's separate in different variables, one per author, using separate function of dplyr. They will be separate by the semi-colon added mannualy after export from Mendeley.
 
 
```{r, message=FALSE, warning=FALSE}
sad2 <- sad1 %>% 
 separate(contributors, into = c("author", "author1", "author2", "author3", "author4", "author5", "author6", "author7", "author8"), sep = ";", extra = "drop")
sad2
```

Select only the authors variables. The first variables contains the semi-colon and will be omitted

```{r}
sad3 <- sad2 %>% 
 select(2:9) 
 


```


# Numer of authors per paper

```{r}

authors_paper <- sad3 %>% 
  mutate(article_id = seq(1:nrow(sad3))) %>% 
     group_by(article_id) %>% 
     gather(author_number, value, -article_id) %>% 
  filter(value != "NA") %>% 
  summarize(n_authors = length(article_id))

sum(authors_paper$n_authors)/105
min(authors_paper$n_authors)
max(authors_paper$n_authors)

authors_paper %>% 
  ggplot(aes(n_authors))+
  geom_histogram()

authors_paper %>% 
  ggplot(aes(x = article_id, n_authors))+
  geom_boxplot()

table(authors_paper$n_authors)

```


# Author frequency data

```{r}
#create the authors data in long format grouped by year
authors <- sad2 %>% 
 select(14, 2:9) %>% 
 group_by(dates) %>% 
 gather(author_order, name, 2:9) %>% 
 ungroup() %>% 
 filter(complete.cases(.)) %>% 
 group_by(dates)

# create the frequency table 
author_table <- data.frame(table(authors$name))

# number of articles per author 
prolific <- author_table %>% 
  filter(Freq >4) 

write.csv(prolific, "prolific.csv", row.names =  T)
prolific

# analyse mean number of coauthors for specific authors
 coauthors <- sad3 %>% 
  mutate(article_id = seq(1:nrow(sad3))) %>%
   group_by(article_id) %>% 
   gather(Name, Value, -article_id) 
 

# remove the comma to clean up the author name
author_table$Var1 <- gsub(',', '', author_table$Var1)
author_table$Var1 <- gsub('', '', author_table$Var1)

author_table %>% 
 ggplot(aes(x = Freq))+
 geom_histogram()

```



# Wordcloud 

```{r, message=FALSE, warning=FALSE}
library(wordcloud)
png("SAD-authors.png", width=12, height=12, units="in", res=300)
cloud<- wordcloud(author_table$Var1, author_table$Freq, c(4,.5), 1, random.order = F, colors=brewer.pal(8, "Dark2"))
dev.off()
cloud

```


# Authorship network 

## Edge and nodes list

Let's create the edge list using the `flatten` function of the `purrr` package. Let's then omit the NA values

```{r}
# generate the list of authors per study
library(purrr)
sad4 <- sad3 %>% select (1:8)
sad_list <- flatten(by_row(sad4, ..f = function(x) flatten_chr(x), .labels = FALSE))
sad_list <- lapply(sad_list, function(x) x[!is.na(x)])

# create the edge list
sad_edge_list <- t(do.call(cbind, lapply(sad_list[sapply(sad_list, length) >= 2], combn, 2)))

```

# Network using igraph 

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(igraph)
# create the network
net=graph.edgelist(as.matrix(sad_edge_list),directed=FALSE)


degree <- data.frame(degree(net))

summary(degree$degree.net.)

between <- data.frame(round(betweenness(net), 1))
page <- data.frame(page_rank(net)$vector)
close <-data.frame(round(closeness(net), 10))
evcent(net)$vector
eigen <- data.frame(round(evcent(net)$vector, 5))
  write.csv(eigen, "eigen.csv")
karate <- net
 wckarate <- walktrap.community(g)

 sapply(unique(membership(wckarate)), function(g) {
    subg1<-induced.subgraph(karate, which(membership(wckarate)==g)) #membership id differs for each cluster
    ecount(subg1)/ecount(karate)
})
 
plot(wckarate, karate)
 #get all combinations of communities
cs <- data.frame(combn(unique(membership(wckarate)),2))
cx <- sapply(cs, function(x) {
    es<-E(karate)[V(karate)[membership(wckarate)==x[1]] %--% 
              V(karate)[membership(wckarate)==x[2]]]    
    length(es)
})
cbind(t(cs),cx)
  
  
png(file="net.png", width=1600,height=900)

plot(net,        vertex.frame.color=V(net)$color,
        edge.width=1.5,
        asp=9/16,
        vertex.size= 1 + 1.5*log(graph.strength(net)),
        vertex.label=ifelse(betweenness(net)>1000,V(net)$name,NA),
     
        vertex.label.color= "black",
        vertex.label.font=2,
        vertex.label.cex=2,
        edge.arrow.size=0.1,
main="Dynamic Network Visualization"
)
dev.off()
degree(net)

```

# Plot using statnet package
```{r}
library(network)
library(intergraph)
net_stat <- asNetwork(net)

jpeg("network_statnet2.jpeg",  width = 1500 , height = 1500, units="px", pointsize=24, quality=100)
set.seed(21)
plot.network(net_stat, vertex.cex= 0.3 + 0.25*log(graph.strength(net)), label =ifelse(degree(net)>19,V(net)$name,NA), label.bg = "white", label.col = "black", edge.col = "grey", label.cex = 1,  displaylabels = TRUE, vertex.col = "#00cc99", jitter = TRUE,  use.len=T, use.curve=T, edge.len = 1, boxed.labels=F, label.border="grey", pad=1)
dev.off()
```


# ggraph

```{r}
library(ggraph)
ggraph(net, 'igraph', algorithm = 'nicely') + 
geom_edge_link2(edge_colour = "grey", edge_alpha = 0.7)+
    geom_node_point(aes(size = degree(net)), color="steelblue") + 
 geom_node_label(aes(label = ifelse(degree(net)>19,V(net)$name,NA)))+
    ggtitle('SAD coauthorship network')+
 theme_graph()+
  ggsave("ggraph_plot.png", width=10, height=10)
    
```


# generate an edge list as dataframe

```{r}
get.edgelist(net)
edge_df <- as.data.frame(get.edgelist(net))
colnames(edge_df) <- c("from", "to")
```



# statistics with networks
## No igraph

```{r}
transitivity(net, type = "global")
diameter(net)
shortest.paths(net)
bet <- betweenness(net)
bet2 <- as.data.frame(bet)
eigen <- as.data.frame(eigen_centrality(net))
rank <-page_rank(net)
rank2 <- as.data.frame(rank$vector)
wc <- cluster_walktrap(net)
modularity(wc)
ms <- membership(wc)
plot(ms, net)
eb <- cluster_edge_betweenness(net)

```

## No statnet

```{r}
fitAuthor <â€ ergm(netstat ~ edges + nodematch("vertex.names"))
```



#  network3D interactive plot

This interactive graph is created from an edge list. It generates a html file. 

```{r}
library(networkD3)
netD3 <- simpleNetwork(edge_df, zoom = T,
              fontFamily = "Arial",
              charge = -100,
              textColour = "black",
              linkDistance = 50,
              nodeColour = "black",
              opacity = 0.65
             )
netD3
 saveNetwork(netD3, file = 'network-SAD.html')

```

 

```{r, include=FALSE}
#Create edges and nodes from data frame
easyMode <- function(df,Index=1){
  df <- as.data.frame(df)
  nodes <- data.frame(name=df[,1:2] %>% unlist %>% as.character() %>% unique())
  nodes[,1] <- as.character(nodes[,1])
  nodes$id <- 1:nrow(nodes)
  
  ## and match to IDs to make edges
  edges <- data.frame(from= match(as.character(df[,1]),nodes$name),
                      to=   match(as.character(df[,2]),nodes$name),
                      value=df[,3])
  
  ## indexing
  if (Index==0){
    edges$from <- as.integer(edges$from - 1)
    edges$to <- as.integer(edges$to - 1)
  }
  list(nodes=nodes,edges=edges)
}
net2 <- easyMode(sad4, Index=0)

```

# Another visualization

```{r, message=FALSE, warning=FALSE, include=FALSE}
forceNetwork(net2$edges, net2$nodes,
            Source = "from", Target = "to",
            Value = "value", NodeID = "name",
            Group = "id", opacity = 0.8, opacityNoHover = TRUE, zoom = TRUE)

```





